import request from 'supertest';
import express from 'express'; // Import express for test app setup
import { pool } from '../db/pool.js';
// Import the setup function for the routes
import setupAuthRoutes from '../routes/auth.js';
// Import the actual db functions module
import * as userDb from '../db/users.js';
// Import necessary functions from Jest globals for ESM (if needed, often implicit)
import { jest, describe, it, expect, beforeAll, afterAll, beforeEach } from '@jest/globals';
// Import the main app's server/io for teardown if needed, and app for middleware tests
import { app as mainApp, server as mainServer, io as mainIo } from '../index.js';
// Import bcryptjs for hashing in tests
import bcrypt from 'bcryptjs';

// Create mock DB functions
const mockUserDb = {
  createUser: jest.fn(),
  getUserByEmail: jest.fn(),
  updateLastLogin: jest.fn(),
  verifyPassword: jest.fn(),
};

// Setup test-specific Express app instance for route testing
const testApp = express();
testApp.use(express.json()); // Add middleware needed by routes
// Mount the auth routes using the setup function and injecting the MOCK DB
testApp.use('/api/auth', setupAuthRoutes(mockUserDb));
// Add a dummy error handler for testing 500 errors
testApp.use((err, req, res, next) => {
    console.error("Test App Error Handler:", err.message); // Log error in test context
    res.status(err.statusCode || 500).json({ error: err.statusCode ? err.message : 'Internal Server Error' });
});
// Note: The dummy /api/test-auth route is NOT part of testApp, it remains on mainApp


// Basic test suite for authentication routes
describe('Auth Routes', () => {
  let testUserEmail = `testuser_di_${Date.now()}@example.com`;
  let testUserPassword = 'password123';
  let testUserName = 'Test User DI';
  let authToken; // Will be generated by successful registration/login mocks

  // Reset mocks before each test
  beforeEach(() => {
    mockUserDb.createUser.mockReset();
    mockUserDb.getUserByEmail.mockReset();
    mockUserDb.updateLastLogin.mockReset();
    mockUserDb.verifyPassword.mockReset();
  });

  // Close the main server and io instance after all tests are done
  // Also close DB pool
  afterAll(async () => {
    mainIo.close();
    await new Promise(resolve => mainServer.close(resolve));
    await pool.end();
  });

  // Test user registration
  it('should register a new user successfully', async () => {
    const mockUserId = `user_${Date.now()}`;
    mockUserDb.createUser.mockResolvedValueOnce({ id: mockUserId, email: testUserEmail, name: testUserName });
    mockUserDb.updateLastLogin.mockResolvedValueOnce(undefined); // Mock updateLastLogin

    const res = await request(testApp) // Use testApp
      .post('/api/auth/register')
      .send({
        email: testUserEmail,
        password: testUserPassword,
        name: testUserName,
      });

    expect(res.statusCode).toEqual(201);
    expect(res.body).toHaveProperty('message', 'User registered successfully');
    expect(res.body).toHaveProperty('user');
    expect(res.body.user).toHaveProperty('id', mockUserId);
    expect(res.body.user).toHaveProperty('email', testUserEmail);
    expect(res.body.user).toHaveProperty('name', testUserName);
    expect(res.body).toHaveProperty('token');
    authToken = res.body.token; // Save token for later tests if needed
    expect(mockUserDb.createUser).toHaveBeenCalledWith(testUserEmail, testUserPassword, testUserName);
    expect(mockUserDb.updateLastLogin).toHaveBeenCalledWith(mockUserId);
  });

  // Test registration with existing email
  it('should fail to register with an existing email', async () => {
    const dbError = new Error('User already exists');
    // Simulate createUser throwing the specific error code/message
    mockUserDb.createUser.mockRejectedValueOnce(dbError);

    const res = await request(testApp) // Use testApp
      .post('/api/auth/register')
      .send({
        email: testUserEmail, // Use an email that triggers the mock error
        password: 'anotherpassword',
        name: 'Another User',
      });

    expect(res.statusCode).toEqual(409);
    expect(res.body).toHaveProperty('error', 'User already exists');
    expect(mockUserDb.createUser).toHaveBeenCalled();
  });

  // --- NEW TEST: POST /register - catch block (generic error) ---
  it('POST /register - should return 500 if database fails unexpectedly', async () => {
      const dbError = new Error('Unexpected DB Error');
      mockUserDb.createUser.mockRejectedValueOnce(dbError);

      const res = await request(testApp) // Use testApp
          .post('/api/auth/register')
          .send({ email: `fail_${Date.now()}@example.com`, password: 'pw', name: 'Fail' });

      expect(res.statusCode).toEqual(500);
      expect(res.body).toHaveProperty('error', 'Internal Server Error');
      expect(mockUserDb.createUser).toHaveBeenCalled();
  });
  // --- END NEW TEST ---

  // Test registration with missing fields
  it('should fail to register with missing fields', async () => {
    const res = await request(testApp) // Use testApp
      .post('/api/auth/register')
      .send({
        email: `missing_${Date.now()}@example.com`,
        // Missing password and name
      });

    expect(res.statusCode).toEqual(400);
    expect(res.body).toHaveProperty('error', 'Email, password, and name are required');
    expect(mockUserDb.createUser).not.toHaveBeenCalled(); // Should fail before DB call
  });

  // Test successful login
  it('should login the registered user successfully', async () => {
    const mockUserId = `user_login_${Date.now()}`;
    const mockHashedPassword = await bcrypt.hash(testUserPassword, 10); // Need a realistic hash
    mockUserDb.getUserByEmail.mockResolvedValueOnce({ id: mockUserId, email: testUserEmail, name: testUserName, password_hash: mockHashedPassword });
    mockUserDb.verifyPassword.mockResolvedValueOnce(true);
    mockUserDb.updateLastLogin.mockResolvedValueOnce(undefined);

    const res = await request(testApp) // Use testApp
      .post('/api/auth/login')
      .send({
        email: testUserEmail,
        password: testUserPassword,
      });

    expect(res.statusCode).toEqual(200);
    expect(res.body).toHaveProperty('message', 'Login successful');
    expect(res.body).toHaveProperty('user');
    expect(res.body.user).toHaveProperty('id', mockUserId);
    expect(res.body).toHaveProperty('token');
    expect(mockUserDb.getUserByEmail).toHaveBeenCalledWith(testUserEmail);
    expect(mockUserDb.verifyPassword).toHaveBeenCalledWith(testUserPassword, mockHashedPassword);
    expect(mockUserDb.updateLastLogin).toHaveBeenCalledWith(mockUserId);
  });

  // Test login with incorrect password
  it('should fail to login with incorrect password', async () => {
    const mockUserId = `user_login_fail_${Date.now()}`;
    const mockHashedPassword = await bcrypt.hash(testUserPassword, 10);
    mockUserDb.getUserByEmail.mockResolvedValueOnce({ id: mockUserId, email: testUserEmail, name: testUserName, password_hash: mockHashedPassword });
    mockUserDb.verifyPassword.mockResolvedValueOnce(false); // Simulate password mismatch

    const res = await request(testApp) // Use testApp
      .post('/api/auth/login')
      .send({
        email: testUserEmail,
        password: 'wrongpassword',
      });

    expect(res.statusCode).toEqual(401);
    expect(res.body).toHaveProperty('error', 'Invalid credentials');
    expect(mockUserDb.getUserByEmail).toHaveBeenCalledWith(testUserEmail);
    expect(mockUserDb.verifyPassword).toHaveBeenCalledWith('wrongpassword', mockHashedPassword);
    expect(mockUserDb.updateLastLogin).not.toHaveBeenCalled();
  });

  // Test login with non-existent email
  it('should fail to login with non-existent email', async () => {
    const nonExistentEmail = `nonexistent_${Date.now()}@example.com`;
    mockUserDb.getUserByEmail.mockResolvedValueOnce(null); // Simulate user not found

    const res = await request(testApp) // Use testApp
      .post('/api/auth/login')
      .send({
        email: nonExistentEmail,
        password: 'somepassword',
      });

    expect(res.statusCode).toEqual(401);
    expect(res.body).toHaveProperty('error', 'Invalid credentials');
    expect(mockUserDb.getUserByEmail).toHaveBeenCalledWith(nonExistentEmail);
    expect(mockUserDb.verifyPassword).not.toHaveBeenCalled();
    expect(mockUserDb.updateLastLogin).not.toHaveBeenCalled();
  });

   // Test login with missing fields
   it('should fail to login with missing fields', async () => {
    const res = await request(testApp) // Use testApp
      .post('/api/auth/login')
      .send({
        email: testUserEmail,
        // Missing password
      });

    expect(res.statusCode).toEqual(400);
    expect(res.body).toHaveProperty('error', 'Email and password are required');
    expect(mockUserDb.getUserByEmail).not.toHaveBeenCalled();
  });

  // --- NEW TEST: POST /login - catch block (getUserByEmail fails) ---
  it('POST /login - should return 500 if getUserByEmail fails', async () => {
      const dbError = new Error('DB get user failed');
      mockUserDb.getUserByEmail.mockRejectedValueOnce(dbError);

      const res = await request(testApp) // Use testApp
          .post('/api/auth/login')
          .send({ email: testUserEmail, password: testUserPassword });

      expect(res.statusCode).toEqual(500);
      expect(res.body).toHaveProperty('error', 'Internal Server Error');
      expect(mockUserDb.getUserByEmail).toHaveBeenCalledWith(testUserEmail);
  });
  // --- END NEW TEST ---

  // --- NEW TEST: POST /login - catch block (verifyPassword fails) ---
  it('POST /login - should return 500 if verifyPassword fails', async () => {
      const mockUserId = `user_login_verify_fail_${Date.now()}`;
      const mockHashedPassword = 'somehash';
      mockUserDb.getUserByEmail.mockResolvedValueOnce({ id: mockUserId, email: testUserEmail, name: testUserName, password_hash: mockHashedPassword });
      const dbError = new Error('bcrypt compare failed');
      mockUserDb.verifyPassword.mockRejectedValueOnce(dbError);

      const res = await request(testApp) // Use testApp
          .post('/api/auth/login')
          .send({ email: testUserEmail, password: testUserPassword });

      expect(res.statusCode).toEqual(500);
      expect(res.body).toHaveProperty('error', 'Internal Server Error');
      expect(mockUserDb.verifyPassword).toHaveBeenCalledWith(testUserPassword, mockHashedPassword);
  });
  // --- END NEW TEST ---

  // --- NEW TEST: POST /login - catch block (updateLastLogin fails) ---
  it('POST /login - should return 500 if updateLastLogin fails', async () => {
      const mockUserId = `user_login_update_fail_${Date.now()}`;
      const mockHashedPassword = await bcrypt.hash(testUserPassword, 10);
      mockUserDb.getUserByEmail.mockResolvedValueOnce({ id: mockUserId, email: testUserEmail, name: testUserName, password_hash: mockHashedPassword });
      mockUserDb.verifyPassword.mockResolvedValueOnce(true);
      const dbError = new Error('DB update last login failed');
      mockUserDb.updateLastLogin.mockRejectedValueOnce(dbError);

      const res = await request(testApp) // Use testApp
          .post('/api/auth/login')
          .send({ email: testUserEmail, password: testUserPassword });

      // Corrected expectation: Error should be caught before response is sent
      expect(res.statusCode).toEqual(500);
      expect(res.body).toHaveProperty('error', 'Internal Server Error');
      expect(mockUserDb.updateLastLogin).toHaveBeenCalledWith(mockUserId);
  });
  // --- END NEW TEST ---


  // --- Middleware Tests ---
  // These tests use the mainApp because the middleware is applied there

  it('should fail protected route without Authorization header', async () => {
    const res = await request(mainApp).get('/api/test-auth'); // Use mainApp
    expect(res.statusCode).toEqual(401);
    expect(res.body).toHaveProperty('error', 'Authentication required');
  });

  it('should fail protected route with malformed Authorization header (no Bearer)', async () => {
    const res = await request(mainApp) // Use mainApp
      .get('/api/test-auth')
      .set('Authorization', 'invalidtoken');
    expect(res.statusCode).toEqual(401);
    expect(res.body).toHaveProperty('error', 'Authentication required');
  });

  // --- NEW TEST: Middleware - Malformed token (Bearer but invalid format) ---
  it('should fail protected route with malformed token (Bearer but invalid)', async () => {
    const res = await request(mainApp) // Use mainApp
      .get('/api/test-auth')
      .set('Authorization', 'Bearer invalid'); // Token doesn't look like JWT
    expect(res.statusCode).toEqual(401);
    expect(res.body).toHaveProperty('error', 'Invalid or expired token'); // Error from jwt.verify
  });
   // --- END NEW TEST ---


  it('should fail protected route with invalid token signature', async () => {
    const res = await request(mainApp) // Use mainApp
      .get('/api/test-auth')
      .set('Authorization', 'Bearer invalidtoken123'); // Invalid signature/content
    expect(res.statusCode).toEqual(401);
    expect(res.body).toHaveProperty('error', 'Invalid or expired token');
  });

  it('should succeed protected route with valid token', async () => {
    // Ensure authToken is set from a successful registration/login test run
    // If tests run independently, might need to register/login here first
    if (!authToken) {
        // Use testApp with mocks to simulate login and get a token
        const mockUserId = `user_get_token_${Date.now()}`;
        const mockHashedPassword = await bcrypt.hash(testUserPassword, 10);
        mockUserDb.getUserByEmail.mockResolvedValueOnce({ id: mockUserId, email: testUserEmail, name: testUserName, password_hash: mockHashedPassword });
        mockUserDb.verifyPassword.mockResolvedValueOnce(true);
        mockUserDb.updateLastLogin.mockResolvedValueOnce(undefined);
        const loginRes = await request(testApp).post('/api/auth/login').send({ email: testUserEmail, password: testUserPassword });
        if (loginRes.statusCode === 200) authToken = loginRes.body.token;
    }
    expect(authToken).toBeDefined();

    const res = await request(mainApp) // Use mainApp
      .get('/api/test-auth')
      .set('Authorization', `Bearer ${authToken}`);
    expect(res.statusCode).toEqual(200);
    expect(res.body).toHaveProperty('message', 'Authenticated!');
    expect(res.body).toHaveProperty('userId');
  });
});
